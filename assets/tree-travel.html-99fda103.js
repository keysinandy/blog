const e=JSON.parse('{"key":"v-0309ad2e","path":"/articles/algorithm/tree-travel.html","title":"二叉树的遍历方式","lang":"zh-CN","frontmatter":{"title":"二叉树的遍历方式","cover":"https://pic.imgdb.cn/item/64a569f21ddac507ccf0a10b.jpg","icon":"page","order":4,"author":"积木","date":"2023-07-05T00:00:00.000Z","tag":["算法"],"sticky":true,"description":"说起二叉树，不得不说二叉树的遍历。 我们可以通过 dfs（深度优先遍历）与 bfs（广度优先遍历）对二叉树进行遍历。 深度优先遍历又可分为前序遍历、中序遍历、后序遍历。 树的遍历一般通过递归可以解决（可能会有调用栈溢出的情况），我们只需要在如下三个地方处理遍历逻辑即可。 假设树节点的数据结构是这样的 interface TreeNode&lt;T = unknown&gt; { left: TreeNode | null; right: TreeNode | null; value: T; }","head":[["meta",{"property":"og:url","content":"https://github.com/keysinandy/blog/articles/algorithm/tree-travel.html"}],["meta",{"property":"og:site_name","content":"学习笔记"}],["meta",{"property":"og:title","content":"二叉树的遍历方式"}],["meta",{"property":"og:description","content":"说起二叉树，不得不说二叉树的遍历。 我们可以通过 dfs（深度优先遍历）与 bfs（广度优先遍历）对二叉树进行遍历。 深度优先遍历又可分为前序遍历、中序遍历、后序遍历。 树的遍历一般通过递归可以解决（可能会有调用栈溢出的情况），我们只需要在如下三个地方处理遍历逻辑即可。 假设树节点的数据结构是这样的 interface TreeNode&lt;T = unknown&gt; { left: TreeNode | null; right: TreeNode | null; value: T; }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pic.imgdb.cn/item/64a569f21ddac507ccf0a10b.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-06T12:29:54.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"二叉树的遍历方式"}],["meta",{"property":"article:author","content":"积木"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2023-07-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-07-06T12:29:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二叉树的遍历方式\\",\\"image\\":[\\"https://pic.imgdb.cn/item/64a569f21ddac507ccf0a10b.jpg\\"],\\"datePublished\\":\\"2023-07-05T00:00:00.000Z\\",\\"dateModified\\":\\"2023-07-06T12:29:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"积木\\"}]}"]]},"headers":[{"level":3,"title":"深度优先遍历","slug":"深度优先遍历","link":"#深度优先遍历","children":[]},{"level":3,"title":"广度优先遍历","slug":"广度优先遍历","link":"#广度优先遍历","children":[]}],"git":{"createdTime":1688646594000,"updatedTime":1688646594000,"contributors":[{"name":"keysin","email":"keysinandy@outlook.com","commits":1}]},"readingTime":{"minutes":3.16,"words":947},"filePathRelative":"articles/algorithm/tree-travel.md","localizedDate":"2023年7月5日","excerpt":"<p>说起二叉树，不得不说二叉树的遍历。</p>\\n<p>我们可以通过 dfs（深度优先遍历）与 bfs（广度优先遍历）对二叉树进行遍历。</p>\\n<p>深度优先遍历又可分为前序遍历、中序遍历、后序遍历。</p>\\n<p>树的遍历一般通过递归可以解决（可能会有调用栈溢出的情况），我们只需要在如下三个地方处理遍历逻辑即可。</p>\\n<p>假设树节点的数据结构是这样的</p>\\n<div class=\\"language-typescript line-numbers-mode\\" data-ext=\\"ts\\"><pre class=\\"language-typescript\\"><code><span class=\\"token keyword\\">interface</span> <span class=\\"token class-name\\">TreeNode<span class=\\"token operator\\">&lt;</span><span class=\\"token constant\\">T</span> <span class=\\"token operator\\">=</span> <span class=\\"token builtin\\">unknown</span><span class=\\"token operator\\">&gt;</span></span> <span class=\\"token punctuation\\">{</span>\\n  left<span class=\\"token operator\\">:</span> TreeNode <span class=\\"token operator\\">|</span> <span class=\\"token keyword\\">null</span><span class=\\"token punctuation\\">;</span>\\n  right<span class=\\"token operator\\">:</span> TreeNode <span class=\\"token operator\\">|</span> <span class=\\"token keyword\\">null</span><span class=\\"token punctuation\\">;</span>\\n  value<span class=\\"token operator\\">:</span> <span class=\\"token constant\\">T</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
